---
title: "Using proteus R package: unlabelled data"
output: 
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Using proteus R package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{css, echo=FALSE}
#pre code, pre, code {
#  white-space: pre !important;
#  overflow-x: scroll !important;
#  word-break: keep-all !important;
#  word-wrap: initial !important;
#}
```

```{r setup, include=FALSE}
library(proteus)
library(knitr)
library(dplyr)
library(reshape)
library(ggplot2)
library(gplots)
library(grid)
require(gridExtra)
library(dendextend)
options(width = 80)
knitr::opts_chunk$set(echo = TRUE)
```

This tutorial demonstrates how to analyse data from unlabelled MS/MS experiment in *Proteus*. It uses example data distributed in a package *proteusUnlabelled*, which needs loading first:

```{r load_data}
library(proteusUnlabelled)
data(proteusUnlabelled)
```

# Input data

## Files

*Proteus* needs one input file: the evidence file from *MaxQuant*.

In this tutorial we are also going to use a metadata file. It should be created manually as a tab-delimited text file with a header containing several columns of metadata. The mandatory columns are "experiment", "measure", "sample" and "condition" (see section [Metadata](#Metadata)).

Alternatively, a metadata data frame (with the same columns) can be created within R session.


## Read evidence file

Function `readEvidenceFile()` reads *MaxQuant* evidence file, filters out contaminants and reverse sequences. In this example we use the evidence file attached to the package:

```{r read_evidence, eval=FALSE}
evidenceFile <- system.file("extdata", "evidence.txt.gz", package="proteusUnlabelled")
evi <- readEvidenceFile(evidenceFile)
```

`evi` is a data frame with selected columns from the evidence file:

```{r head_evidence}
head(evi)
```

This can be a large object:

```{r size_evidence}
dim(evi)
format(object.size(evi), units="Mb")
```


## Columns in evidence file

*MaxQuant* evidence files come with column names that can differ, depending on the *MaxQuant* version and the parameters used in its run. Many of these column names contain spaces and other characters (e.g. "/") that make R data processing awkward. Therefore, upon reading the evidence file, `proteus` renames its columns to simpler names, conforming with R variable name restrictions. Also, many of the evidence columns are not needed in `proteus` processing, so these are not kept to save memory.

The selection and naming of columns is controlled by two parameters in function `readEvidenceFile()`: `measure.cols` and `data.cols`. If not provided, `readEvidenceFile()` will use the default lists.

The named list `measureColumns` contains only one column with measurements, as appropriate for unlabelled proteomics:

```{r str_measure_columns}
str(measureColumns)
```

Different measure columns are needed for TMT and Silac experiments.

The named list `evidenceColumns` contains a minimal set of columns needed for further processing (in addition to measure columns).

```{r str_evidence_columns}
str(evidenceColumns)
```

The names (`sequence`, `modseq`, and so on) are used internally in the package and should not be changed. The values (`Sequence`, `Modified sequence`) are the actual column names in the evidence file and can be adjusted if different naming convention is used. We suggest not to change the default list, but create a copy, which can be modified. Let's say we want to read column `m/z` as well:

```{r my_columns, eval=FALSE}
myColumns <- c(evidenceColumns, mz="m/z")
```

The new column list can be used with `readEvidenceFile`:

```{r my_columns_evidence, eval=FALSE}
evi_mz <- readEvidenceFile(evidenceFile, columns=myColumns)
```

To quickly check what the column names are in a given evidence file, we can read one row and see its names:

```{r evidence_column_names}
evidenceFile <- system.file("extdata", "evidence.txt.gz", package="proteusUnlabelled")
evicols <- read.delim(evidenceFile, header=TRUE, sep="\t", check.names=FALSE, nrows=1)
names(evicols)
```

## <a id="Metadata"></a>Metadata

We also need metadata. In our example it is stored in the file attached to the package:

```{r metadata}
metadataFile <- system.file("extdata", "metadata.txt", package="proteusUnlabelled")
meta <- read.delim(metadataFile, header=TRUE, sep="\t")
```

It contains the design of our experiment:

```{r show_metadata}
meta
```

This metadata information will be attached to every peptide and protein object used by Proteus.

### Metadata columns

Metadata object should be a data frame with at least four columns: `experiment`, `measure`, `sample` and `condition`.

- Column `experiment` should contain the same values as in the `Experiment` column in the evidence file. In our case there are 14 unique experiments. We can see all unique experiment names in the evidence data using `unique` function:

```{r metadata_samples}
unique(evi$experiment)
```

- Column `measure` refers to measure columns in the evidence file. In case of an unlabelled experiment there is only one measure column, "Intensity". In multiplexed data there can be several measure columns.

- `sample` is a (short) name corresponding to a given experiment and measure. For clarity, we recommend a short name consisting of a condition and replicate (in a simple design where such decomposition is possible). Sample identifies a given experiment/measure uniquely, so sample names must be unique.

- `condition` contains condition names. This information will be used in differential expression. In our example there are two conditions, hence two values in this column.

Other columns can be added and used for the downstream analysis. Here, we added a `replicate` column, but other information, in particular describing batch effects, can be very useful.

# Peptide data

## Create a peptide dataset

We can now create a peptide data object from the evidence and metadata. The function `makePeptideTable()` creates table, where rows correspond to peptides and columns correspond to samples (as provided in metadata). Where there are multiple peptides corresponding to the same sequence/sample (e.g., with different charges) their intensities are added in unlabelled data (we warn that this might not be the best approach due to presence of downliers in peptide data - more to come soon).

```{r make_peptides, eval=FALSE}
pepdat <- makePeptideTable(evi, meta)
```

`pepdat` is an object of class `proteusData`. It consists of the intensity table (`pepdat$tab`) and additional information. The first fife rows and columns from the intensity table are

```{r show_peptides}
pepdat$tab[1:5, 1:5]
```

We can use generic `summary` function to see more information about `pepdat`.

```{r summary_peptides}
summary(pepdat)
```

## Number of peptides

Function `plotCount()` plots, as the name suggests, peptide count in each sample. This is the number of non-zero peptide intensities per sample. 

```{r plot_peptide_count, fig.width=5, fig.height=4}
plotCount(pepdat)
```

## Jaccard similarity

Function `plotDetectionSimilarity()` calculates Jaccard similarity between each pair of samples and plots its distribution. The similarity is based on detection. For a pair of samples it compares the number of detected peptides in both samples (intersection) divided by the total number of peptides detected in both samples (union). This measure of similarity is a number between 0 and 1.

```{r plot_detection_similarity, fig.width=5, fig.height=4}
plotDetectionSimilarity(pepdat, bin.size = 0.02)
```

## Distance matrix

Function `plotDistanceMatrix()` calculates the Pearson's correlation coefficient for each pair of samples and plots a heatmap:

```{r plot_correlation_matrix, fig.width=6, fig.height=5}
plotDistanceMatrix(pepdat)
```

## Clustering

We can use `plotClustering()` to see a dendrogram of the peptide data set:

```{r plot_clusterin, fig.width=6, fig.height=5}
plotClustering(pepdat)
```

## Removing bad data

The last sample (BMO-7) in the example data looks odd. Lets say we call it "bad" and want to remove from analysis. The easiest way to do this is to modify the metadata.

Warning: this is only an example. You should exercise caution when removing any of your data.

```{r remove_bad_replicate}
meta.clean <- meta[which(meta$sample  != 'BMO-7'),]
```

Now, we create a new "clean" peptide data set from evidence data:

```{r make_clean_peptides, eval=FALSE}
pepdat.clean <- makePeptideTable(evi, meta.clean)
```

The new data `pepdat.clean` will contain only samples included in the metadata, that is

```{r clean_peptides_samples}
as.character(meta.clean$sample)
```


Clustering confirms that the offending sample is gone.

```{r, fig.width=6, fig.height=5}
plotClustering(pepdat.clean)
```


# Protein data

There are many approaches to aggregating peptides into proteins. For simplicity, we assign peptides to proteins based on the Leading Razor Protein. For unlabelled data, we quantify protein abundances using a simple, but robust method of high-fliers ([Silva et al. 2006](http://www.mcponline.org/content/5/1/144.full.pdf)).

## Create protein dataset

`makeProteinTable()` creates a protein data set from the peptide data. The result is a `proteusData` object containing protein intensity table and other information.

```{r make_proteins, eval=FALSE}
prodat <- makeProteinTable(pepdat.clean)
```

Again, we can use a generic `summary` function to see its properties.

```{r summary_proteins}
summary(prodat)
```

## Normalization

Finally, we need to normalize data to account for variation of intensity between samples. The function `normalizeData()` can normalize peptide or protein data. Up to this point, we haven't applied any normalization. The default normalization is to the median. After this step, median sample intensities will be equal.

```{r normalize_proteins}
prodat.med <- normalizeData(prodat)
```

The second parameter to `normalizeData()` is `norm.fun` and it points to a normalizing function. By default, this is `normalizeMedian`, but other normalizations can be used. For example, it works with `normalizeQuantiles` from `limma` package:

```{r normalize_proteins_quantiles}
prodat.quant <- normalizeData(prodat, norm.fun=limma::normalizeQuantiles)
```

The function `plotSampleDistributions()` can be used to compare intensity distributions for each normalization.

```{r intensity_distributions_1, fig.width=5, fig.height=4}
plotSampleDistributions(prodat, title="Not normalized", fill="condition", method="violin")
```

```{r intensity_distributions_2, fig.width=5, fig.height=4}
plotSampleDistributions(prodat.med, title="Median normalization", fill="condition", method="violin")
```

```{r intensity_distributions_3, fig.width=5, fig.height=4}
plotSampleDistributions(prodat.quant, title="Quantile normalization", fill="condition", method="violin")
```




## Mean-variance relationship

Some statistics (like mean and variance across replicate in each condition) are stored directly in the `prodat` object at the moment of creation. We can apply `plotMV()` function to plot the mean-variance relationship.

```{r plot_mv, fig.width=6, fig.height=4, warning=FALSE}
plotMV(prodat.med, with.loess=TRUE)
```

## Protein clustering

We can use the same function `plotClustering()` to see the dendrogram for the proteins.

```{r plot_clustering_proteins, fig.width=6, fig.height=5}
plotClustering(prodat.med)
```

# Differential expression

We suggest using [limma](http://bioconductor.org/packages/release/bioc/html/limma.html) package to do differential expression. Package `proteus` contains a simple wrapper to limma, that takes a `proteusData` object as input.

```{r limma, warning=FALSE}
res <- limmaDE(prodat.med, sig.level=0.05)
```

This function creates a data frame with DE results.

```{r show_limma_res}
head(res)
```

Before `limma` is called, intensity data are transformed using the `transform.fun` function (a parameter of `limmaDE`). The default value for this transformation is `log10`. Therefore, by default, the column `logFC` in the output data frame contains log10(M_1/M_2), where M_k represent the mean of condition k. If you need log2-based fold change, you can use `transform.fun=log2`.

The `significant` column indicates significantly differntially expressed proteins, based on the Benjamini-Hochberg corrected p-values (column `adj.P.Val`) and the significance level defined when calling `limmaDE` (`sig.level=0.05`). It allows for simple filtering of the significant results (below we show only the most important columns, for simplicity):

```{r show_significant_proteins}
res[which(res$significant), c("protein", "logFC", "adj.P.Val")]
```

Note: `limmaDE` requires exactly two conditions to do a differential expression on. When data contain more conditions, a parameter `conditions` is required to select a pair:

```{r limma_conditions, eval=FALSE}
res <- limmaDE(prodat.med, conditions=c("1112", "BMO"))
```

For more complicated designs we recommend using [limma](http://bioconductor.org/packages/release/bioc/html/limma.html) functions directly.

## Proteins present in only one condition

Sometimes data for a given protein is missing entirely from a condition (that is all replicates are `NA` in the intensity table). In such cases, differential expression with `limma` returns `NA` log-fold-change and p-value. However, a protein detected in one condition and not detected in the other condition might be interesting if a non-detection is due to very low abundance. We can easily find such proteins using the look-up table `detect` in an `proteusData` object. It contains logical columns for each condition, with `TRUE` indicating that the protein was detected (in at least one replicate) and `FALSE` when it was not detected (in any replicate).

```{r protein_detection}
head(prodat$detect)
```

The first protein, `1112-yEGFP` is not detected in `BMO` condition. The proteins detected in only one condition can be found using a logical expression:

```{r missing_condition}
only.1112 <- which(prodat$detect$`1112` & !prodat$detect$BMO)
only.BMO <- which(!prodat$detect$`1112` & prodat$detect$BMO)
```

We can list their identifiers from the `proteins` field in the protein object, as in this example for condition `1112`:

```{r missing_condition_proteins}
as.character(prodat$proteins[only.1112])
```


## Visualization

`proteus` provides with several functions to visualize protein data and the results of the differential expression.

Fold-change-intensity plot:

```{r plot_fid, fig.width=4, fig.height=4, warning=FALSE}
plotFID(prodat.med)
```

Volcano plot:

```{r plot_volcano, fig.width=4, fig.height=4, warning=FALSE}
plotVolcano(res)
```

P-value distribution plot:

```{r plot_pdist, fig.width=4, fig.height=4, warning=FALSE}
plotPdist(res)
```


## Individual proteins

We can also look at individual protein. The function `plotIntensities` plots intensities of individual samples per condition, or other selected quantity (e.g. batch). Here is one of the up-regulated proteins.

```{r plot_proteins, fig.width=4, fig.height=4, warning=FALSE}
plotIntensities(prodat.med, id='sp|P26263|PDC6_YEAST', log=TRUE)
```

A better understanding of the protein's behaviour might be gained via function `plotProtPeptides`, which shows intensities of individual peptides and replicates for the given protein.

```{r plot_prot_peptides, fig.width=7, fig.height=6, warning=FALSE}
plotProtPeptides(pepdat.clean, 'sp|P26263|PDC6_YEAST', prodat.med)
```
