---
title: "Using proteus R package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using proteus R package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{css}
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
```

```{r setup, include=FALSE}
library(proteus)
library(knitr)
library(dplyr)
library(reshape)
library(ggplot2)
library(gplots)
library(grid)
require(gridExtra)
library(dendextend)
options(width = 1000)
knitr::opts_chunk$set(echo = TRUE)
```

## Input data

### Files

We need two files for proteus. The MaxQuant evidence file and a manually created metadata file. The metadata file is a tab-delimited text file with a header containing several columns of metadata. The mandatory columns are "sample" and "condition".

```{r}
evidenceFile <- '../inst/extdata/evidence.txt'
metadataFile <- '../inst/extdata/metadata.txt'
```


### Read evidence file

`readEvidenceFile()` reads MaxQuant's evidence file, filters out contaminants and reverse sequences:

```{r, eval=FALSE}
evi <- readEvidenceFile(evidenceFile)
```

`evi` is a data frame with selected columns from the evidence file:

```{r}
head(evi)
```

### Columns in evidence file

The selection of columns is controlled by a parameter `columns` in `readEvidenceFile()`. If not provided, `readEvidenceFile()` will use the default list `evidenceColumns`.

```{r}
str(evidenceColumns)
```

The list names (`sequence`, `modseq`, and so on) are used internally in the package and should not be changed. The values (`Sequence`, `Modified sequence`) are column names in the evidence file and can be adjusted if different naming convention is used. We suggest not to change the default list, but create a copy, which can be modified. Let's say we want to read column `m/z` as well:

```{r, eval=FALSE}
myColumns <- c(evidenceColumns, mz="m/z")
```

The new column list can be used with `readEvidenceFile`:

```{r, eval=FALSE}
evi <- readEvidenceFile(evidenceFile, columns=myColumns)
```


### Metadata

We also need metadata. In our example it is in the file:

```{r, eval=FALSE}
meta <- read.delim(metadataFile, header=TRUE, sep="\t")
```

It contains the design of our experiment:

```{r}
meta
```

Metadata object should be a data frame with at least two columns: `sample` and `condition`.

`sample` corresponds to the experiment name in MaxQuant's terminology. We can easily see all experiment names in the evidence data:

```{r}
levels(as.factor(evi$experiment))
```

Our `sample` column can contain either all, or selected, experiment names.

Column `condition` contains, *nomen-omen*, condition names. In our example there are two conditions, hence two values in this column.

Other columns can be added and used for the downstream analysis.


## Peptide data

### Create a peptide dataset

We can now create a peptide data object from the evidence and metadata. The function `makePeptideTable()` creates a "cast" (terminology from the [reshape2](https://cran.r-project.org/web/packages/reshape2/reshape2.pdf) package) converting a long format of the evidence data (each peptide and sample in a separate row) into a wide format, where rows correspond to peptides and columns correspond to samples. Where there are multiple peptides corresponding to the same sequence/sample (e.g., with different charges) their intensities are added.


```{r, eval=FALSE}
pepdat <- makePeptideTable(evi, meta)
```

`pepdat` is an object of class `proteusData`. It consists of the intensity table (`pepdat$tab`) and additional information. The first fife rows and columns from the intensity table are

```{r}
pepdat$tab[1:5, 1:5]
```

Here is a list of all fields from the object:

```{r}
names(pepdat)
```

### Number of peptides

First, let's check the total number of peptides and proteins.

```{r}
length(pepdat$peptides)
length(pepdat$proteins)
```

Function `plotPeptideCount()` plots, as the name suggests, peptide count in each sample. This is the number of non-zero peptide intensities per sample. 

```{r, fig.width=5, fig.height=5}
plotPeptideCount(pepdat)
```

### Correlation matrix

Function `plotCorrelationMatrix` calculates the Pearson's correlation coefficient for each pair of samples and plots a heatmap:

```{r, fig.width=7, fig.height=6}
plotCorrelationMatrix(pepdat)
```

### Clustering

We can use `plotClustering` to see a dendrogram of the peptide dataset:

```{r, fig.width=6, fig.height=5}
plotClustering(pepdat)
```

### Removing bad data

The last sample (BMO-7) looks odd. Lets say we call it "bad" and want to remove from analysis. The easiest way to do this is to modify the metadata.

Warning: this is only a demonstration. You should excersise caution when removing any of your data.

```{r}
meta.clean <- meta[which(meta$sample  != 'BMO-7'),]
```

Now, we create a new "clean" peptide dataset:

```{r, eval=FALSE}
pepdat.clean <- makePeptideTable(evi, meta.clean)
```

The new data `pepdat.clean` will contain only samples included in the metadata, that is

```{r}
as.character(meta.clean$sample)
```


Clustering confirms that the offending sample is gone.

```{r, fig.width=6, fig.height=5}
plotClustering(pepdat.clean)
```


## Protein data

There are many approaches to aggregating peptides into proteins. For simplicity, we assign peptides to proteins based on the Leading Razor Protein. We quantify protein abundances using a simple, but robust method of high-fliers ([Silva et al. 2006](http://www.mcponline.org/content/5/1/144.full.pdf)).

### Create protein dataset

`makeProteinTable()` creates a protein data set from the peptide data. The result is a `proteusData` object containing protein intensity table and other informtaion.

```{r, eval=FALSE}
prodat <- makeProteinTable(pepdat.clean)
```

### Mean-variance relationship

Some statistics (like mean and variance across replicate in each condition) are stored directly in the `prodat` object at the moment of creation. We can apply `plotMV` function to plot the mean-variance relationship.

```{r, fig.width=7, fig.height=6, warning=FALSE}
plotMV(prodat, with.loess=TRUE)
```

### Protein clustering

We can use the same function `plotClustering` to see the dendrogram for the proteins.

```{r, fig.width=6, fig.height=5}
plotClustering(prodat)
```

## Differential expression

We suggest using `limma` package to do differential expression. Package `proteus` contains a simple wrapper to limma, that takes `proteusData` as input:

```{r, warning=FALSE}
ebay <- limmaDE(prodat)
res <- limmaTable(prodat, ebay)
```

The first function, `limmaDE` performs differential expression on the intensity table inside `prodat` object, based on the provided formula (default is "~condition"). The second function, `limmaTable` creates a simple table with DE results.

```{r}
head(res)
```

According to a traditional definition of "significance", the number of significantly differentially expressed proteins is

```{r}
significant <- which(res$adj.P.Val <= 0.05)
length(significant)
```

Since the number is small, we can just print the whole list:

```{r}
res[significant,]
```

### Visualization

`proteus` provides with several functions to visualize protein data and the results of the differential expression.

Fold-change-intensity plot:

```{r, fig.width=5, fig.height=5, warning=FALSE}
plotFID(prodat)
```

Volcano plot:

```{r, fig.width=5, fig.height=5, warning=FALSE}
plotVolcano(res)
```

P-value distribution plot:

```{r, fig.width=5, fig.height=5, warning=FALSE}
plotPdist(res)
```


### Individual proteins

We can also look at individual protein. The function `plotProteins` plots intensities of individual samples per condition, or other selected quantity (e.g. batch). Here is one of the up-regulated proteins.

```{r, fig.width=4, fig.height=4, warning=FALSE}
plotProteins(prodat, protein='sp|P26263|PDC6_YEAST', log=TRUE)
```

A better understanding of the protein's behaviour might be gained via function `plotProtPeptides`, which shows intensities of individual peptides and replicates for the given protein.

```{r, fig.width=7, fig.height=6, warning=FALSE}
plotProtPeptides(pepdat.clean, 'sp|P26263|PDC6_YEAST', prodat)
```
