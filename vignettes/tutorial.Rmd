---
title: "Using proteus R package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using proteus R package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{css, echo=FALSE}
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
```

```{r setup, include=FALSE}
library(proteus)
library(knitr)
library(dplyr)
library(reshape)
library(ggplot2)
library(gplots)
library(grid)
require(gridExtra)
library(dendextend)
options(width = 1000)
knitr::opts_chunk$set(echo = TRUE)
```

## Input data

### Files

Proteus needs one input file: the evidence file from *MaxQuant*.

In this tutorial we are also going to use a metadata file. It should be created manually as a tab-delimited text file with a header containing several columns of metadata. The mandatory columns are "sample" and "condition" (no capital letters).

Alternatively, a metadata data frame (with the same columns) can be created in R.


### Read evidence file

Function `readEvidenceFile()` reads *MaxQuant* evidence file, filters out contaminants and reverse sequences. In this example we use the evidence file attached to the package:

```{r read_evidence, eval=FALSE}
evidenceFile <- system.file("extdata", "evidence.txt.gz", package="proteus")
xpevi <- readEvidenceFile(evidenceFile)
```

`xpevi` is a data frame with selected columns from the evidence file:

```{r head_evidence}
head(xpevi)
```

This can be a large object:

```{r size_evidence}
dim(xpevi)
object.size(xpevi)
```


### Columns in evidence file

*MaxQuant* evidence files come with column names that can differ, depending on the *MaxQuant* version and the parameters used in its run. Many of these column names contain spaces and other characters (e.g. "/") that make R data processing awkward. Therefore, upon reading the evidence file, `proteus` renames its columns to simpler names, conforming with R variable name restrictions. Also, many of the evidence columns are not needed in `proteus` processing, so these are not kept to save memory.

The selection and naming of columns is controlled by two parameters in function `readEvidenceFile()`: `measure.cols` and `data.cols`. If not provided, `readEvidenceFile()` will use the default lists.

The named list `measureColumns` contains only one column with measurements, as appropriate for unlabelled proteomics:

```{r str_measure_columns}
str(measureColumns)
```

Different measure columns are needed for TMT and Silac experiments.

The named list `evidenceColumns` contains a minimal set of columns needed for further processing (in addition to measure columns).

```{r str_evidence_columns}
str(evidenceColumns)
```

The names (`sequence`, `modseq`, and so on) are used internally in the package and should not be changed. The values (`Sequence`, `Modified sequence`) are the actual column names in the evidence file and can be adjusted if different naming convention is used. We suggest not to change the default list, but create a copy, which can be modified. Let's say we want to read column `m/z` as well:

```{r my_columns, eval=FALSE}
myColumns <- c(evidenceColumns, mz="m/z")
```

The new column list can be used with `readEvidenceFile`:

```{r my_columns_evidence, eval=FALSE}
xpevi_mz <- readEvidenceFile(evidenceFile, columns=myColumns)
```

To quickly check what the column names in a given evidence file are, we can read one row and see its names:

```{r evidence_column_names}
evidenceFile <- system.file("extdata", "evidence.txt.gz", package="proteus")
evicols <- read.delim(evidenceFile, header=TRUE, sep="\t", check.names=FALSE, nrows=1)
names(evicols)
```

### Metadata

We also need metadata. In our example it is in the file:

```{r metadata}
metadataFile <- system.file("extdata", "metadata.txt", package="proteus")
xpmeta <- read.delim(metadataFile, header=TRUE, sep="\t")
```

It contains the design of our experiment:

```{r show_metadata}
xpmeta
```

Metadata object should be a data frame with at least two columns: `sample` and `condition`.

`sample` corresponds to the experiment name in *MaxQuant's* terminology. We can easily see all experiment names in the evidence data:

```{r metadata_samples}
levels(as.factor(xpevi$experiment))
```

Our `sample` column can contain either all, or selected, experiment names.

Column `condition` contains, *nomen-omen*, condition names. In our example there are two conditions, hence two values in this column.

Other columns can be added and used for the downstream analysis.

## Peptide data

### Create a peptide dataset

We can now create a peptide data object from the evidence and metadata. The function `makePeptideTable()` creates a "cast" (terminology from the [reshape2](https://cran.r-project.org/web/packages/reshape2/reshape2.pdf) package) converting a long format of the evidence data (each peptide and sample in a separate row) into a wide format, where rows correspond to peptides and columns correspond to samples. Where there are multiple peptides corresponding to the same sequence/sample (e.g., with different charges) their intensities are added (we warn that this might not be the best approach due to presence of downliers in peptide data - more to come soon).

```{r make_peptides, eval=FALSE}
xppepdat <- makePeptideTable(xpevi, xpmeta)
```

`xppepdat` is an object of class `proteusData`. It consists of the intensity table (`xppepdat$tab`) and additional information. The first fife rows and columns from the intensity table are

```{r show_peptides}
xppepdat$tab[1:5, 1:5]
```

We can use generic `summary` function to see more information about `xppepdat`.

```{r summary_peptides}
summary(xppepdat)
```

### Number of peptides

Function `plotPeptideCount()` plots, as the name suggests, peptide count in each sample. This is the number of non-zero peptide intensities per sample. 

```{r plot_peptide_count, fig.width=5, fig.height=4}
plotPeptideCount(xppepdat)
```

### Jaccard similarity

Function `plotDetectionSimilarity()` calculates Jaccard similarity between each pair of samples and plots its distribution. The similarity is based on detection. For a pair of samples it compares the number of detected peptides in both samples (intersection) divided by the total number of peptides detected in both samples (union). This measure of similarity is a number between 0 and 1.

```{r plot_detection_similarity, fig.width=5, fig.height=4}
plotDetectionSimilarity(xppepdat, bin.size = 0.02)
```

### Distance matrix

Function `plotDistanceMatrix` calculates the Pearson's correlation coefficient for each pair of samples and plots a heatmap:

```{r plot_correlation_matrix, fig.width=6, fig.height=5}
plotDistanceMatrix(xppepdat)
```

### Clustering

We can use `plotClustering` to see a dendrogram of the peptide data set:

```{r plot_clusterin, fig.width=6, fig.height=5}
plotClustering(xppepdat)
```

### Removing bad data

The last sample (BMO-7) in the example data looks odd. Lets say we call it "bad" and want to remove from analysis. The easiest way to do this is to modify the metadata.

Warning: this is only an example. You should exercise caution when removing any of your data.

```{r remove_bad_replicate}
xpmeta.clean <- xpmeta[which(xpmeta$sample  != 'BMO-7'),]
```

Now, we create a new "clean" peptide data set:

```{r make_clean_peptides, eval=FALSE}
xppepdat.clean <- makePeptideTable(xpevi, xpmeta.clean)
```

The new data `xppepdat.clean` will contain only samples included in the metadata, that is

```{r clean_peptides_samples}
as.character(xpmeta.clean$sample)
```


Clustering confirms that the offending sample is gone.

```{r, fig.width=6, fig.height=5}
plotClustering(xppepdat.clean)
```


## Protein data

There are many approaches to aggregating peptides into proteins. For simplicity, we assign peptides to proteins based on the Leading Razor Protein. We quantify protein abundances using a simple, but robust method of high-fliers ([Silva et al. 2006](http://www.mcponline.org/content/5/1/144.full.pdf)).

### Create protein dataset

`makeProteinTable()` creates a protein data set from the peptide data. The result is a `proteusData` object containing protein intensity table and other information.

```{r make_proteins, eval=FALSE}
xpprodat <- makeProteinTable(xppepdat.clean)
```

Again, we can use a generic `summary` function to see its properties.

```{r summary_proteins}
summary(xpprodat)
```

### Normalization

Finally, we need to normalize data to account for variation of intensity between samples. The function `normalizeData()` can normalize peptide or protein data. Up to this point, we haven't applied any normalization. The default normalization is to the median. After this step, median sample intensities will be equal.

```{r normalize_proteins}
xpprodat.med <- normalizeData(xpprodat)
```

The second parameter to `normalizeData()` is `norm.fun` and it points to a normalizing function. By default, this is `normalizeMedian`, but other normalizations can be used. For example, it works with `normalizeQuantiles` from `limma` package:

```{r normalize_proteins_quantiles}
xpprodat.quant <- normalizeData(xpprodat, norm.fun=limma::normalizeQuantiles)
```

The function `plotSampleDistributions` can be used to compare intensity distributions for each normalization.

```{r intensity_distributions_1, fig.width=5, fig.height=4}
plotSampleDistributions(xpprodat, title="Not normalized", fill="condition", method="violin")
```

```{r intensity_distributions_2, fig.width=5, fig.height=4}
plotSampleDistributions(xpprodat.med, title="Median normalization", fill="condition", method="violin")
```

```{r intensity_distributions_3, fig.width=5, fig.height=4}
plotSampleDistributions(xpprodat.quant, title="Quantile normalization", fill="condition", method="violin")
```




### Mean-variance relationship

Some statistics (like mean and variance across replicate in each condition) are stored directly in the `prodat` object at the moment of creation. We can apply `plotMV` function to plot the mean-variance relationship.

```{r plot_mv, fig.width=6, fig.height=4, warning=FALSE}
plotMV(xpprodat.med, with.loess=TRUE)
```

### Protein clustering

We can use the same function `plotClustering` to see the dendrogram for the proteins.

```{r plot_clustering_proteins, fig.width=6, fig.height=5}
plotClustering(xpprodat.med)
```

## Differential expression

We suggest using [limma](http://bioconductor.org/packages/release/bioc/html/limma.html) package to do differential expression. Package `proteus` contains a simple wrapper to limma, that takes `proteusData` as input:

```{r limma, warning=FALSE}
ebay <- limmaDE(xpprodat.med)
res <- limmaTable(xpprodat.med, ebay)
```

The first function, `limmaDE` performs differential expression on the intensity table inside `prodat` object, based on the provided formula (default is "~condition", but other formulae can be provided via `formula` argument). The second function, `limmaTable` creates a simple table with DE results.

```{r show_limma_res}
head(res)
```

The `adj.P.Val` column contains Benjamini-Hochberg corrected p-values. According to a traditional definition of "significance", the number of significantly differentially expressed proteins is

```{r significant_protein_number}
significant <- which(res$adj.P.Val <= 0.05)
length(significant)
```

Since the number is small, we can just print the whole list:

```{r show_significant_proteins}
res[significant,]
```

### Visualization

`proteus` provides with several functions to visualize protein data and the results of the differential expression.

Fold-change-intensity plot:

```{r plot_fid, fig.width=4, fig.height=4, warning=FALSE}
plotFID(xpprodat.med)
```

Volcano plot:

```{r plot_volcano, fig.width=4, fig.height=4, warning=FALSE}
plotVolcano(res)
```

P-value distribution plot:

```{r plot_pdist, fig.width=4, fig.height=4, warning=FALSE}
plotPdist(res)
```


### Individual proteins

We can also look at individual protein. The function `plotProteins` plots intensities of individual samples per condition, or other selected quantity (e.g. batch). Here is one of the up-regulated proteins.

```{r plot_proteins, fig.width=4, fig.height=4, warning=FALSE}
plotProteins(xpprodat.med, protein='sp|P26263|PDC6_YEAST', log=TRUE)
```

A better understanding of the protein's behaviour might be gained via function `plotProtPeptides`, which shows intensities of individual peptides and replicates for the given protein.

```{r plot_prot_peptides, fig.width=7, fig.height=6, warning=FALSE}
plotProtPeptides(xppepdat.clean, 'sp|P26263|PDC6_YEAST', xpprodat.med)
```
